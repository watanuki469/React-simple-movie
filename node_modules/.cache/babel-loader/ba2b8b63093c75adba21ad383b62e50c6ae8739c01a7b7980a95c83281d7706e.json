{"ast":null,"code":"import React, { useEffect, useLayoutEffect, createContext, useContext, useMemo, useState, createElement, useRef, useCallback } from 'react';\n\n// Global state used to deduplicate requests and store listeners\nconst SWRGlobalState = new WeakMap();\nconst EMPTY_CACHE = {};\nconst noop = () => {};\n// Using noop() as the undefined value as undefined can be replaced\n// by something else. Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nconst UNDEFINED = /*#__NOINLINE__*/noop();\nconst OBJECT = Object;\nconst isUndefined = v => v === UNDEFINED;\nconst isFunction = v => typeof v == 'function';\nconst mergeObjects = (a, b) => ({\n  ...a,\n  ...b\n});\nconst STR_UNDEFINED = 'undefined';\n// NOTE: Use the function to guarantee it's re-evaluated between jsdom and node runtime for tests.\nconst isWindowDefined = typeof window != STR_UNDEFINED;\nconst isDocumentDefined = typeof document != STR_UNDEFINED;\nconst hasRequestAnimationFrame = () => isWindowDefined && typeof window['requestAnimationFrame'] != STR_UNDEFINED;\nconst createCacheHelper = (cache, key) => {\n  const state = SWRGlobalState.get(cache);\n  return [\n  // Getter\n  () => cache.get(key) || EMPTY_CACHE,\n  // Setter\n  info => {\n    const prev = cache.get(key);\n    state[5](key, mergeObjects(prev, info), prev || EMPTY_CACHE);\n  },\n  // Subscriber\n  state[6]];\n};\n\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nconst table = new WeakMap();\n// counter of the key\nlet counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\nconst stableHash = arg => {\n  const type = typeof arg;\n  const constructor = arg && arg.constructor;\n  const isDate = constructor == Date;\n  let result;\n  let index;\n  if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {\n    // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n    // If it's already hashed, directly return the result.\n    result = table.get(arg);\n    if (result) return result;\n    // Store the hash first for circular reference detection before entering the\n    // recursive `stableHash` calls.\n    // For other objects like set and map, we use this id directly as the hash.\n    result = ++counter + '~';\n    table.set(arg, result);\n    if (constructor == Array) {\n      // Array.\n      result = '@';\n      for (index = 0; index < arg.length; index++) {\n        result += stableHash(arg[index]) + ',';\n      }\n      table.set(arg, result);\n    }\n    if (constructor == OBJECT) {\n      // Object, sort keys.\n      result = '#';\n      const keys = OBJECT.keys(arg).sort();\n      while (!isUndefined(index = keys.pop())) {\n        if (!isUndefined(arg[index])) {\n          result += index + ':' + stableHash(arg[index]) + ',';\n        }\n      }\n      table.set(arg, result);\n    }\n  } else {\n    result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n  }\n  return result;\n};\n\n/**\n * Due to the bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\n * it's not reliable to detect if the browser is currently online or offline\n * based on `navigator.onLine`.\n * As a workaround, we always assume it's online on the first load, and change\n * the status upon `online` or `offline` events.\n */\nlet online = true;\nconst isOnline = () => online;\n// For node and React Native, `add/removeEventListener` doesn't exist on window.\nconst [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [window.addEventListener.bind(window), window.removeEventListener.bind(window)] : [noop, noop];\nconst isVisible = () => {\n  const visibilityState = isDocumentDefined && document.visibilityState;\n  return isUndefined(visibilityState) || visibilityState !== 'hidden';\n};\nconst initFocus = callback => {\n  // focus revalidate\n  if (isDocumentDefined) {\n    document.addEventListener('visibilitychange', callback);\n  }\n  onWindowEvent('focus', callback);\n  return () => {\n    if (isDocumentDefined) {\n      document.removeEventListener('visibilitychange', callback);\n    }\n    offWindowEvent('focus', callback);\n  };\n};\nconst initReconnect = callback => {\n  // revalidate on reconnected\n  const onOnline = () => {\n    online = true;\n    callback();\n  };\n  // nothing to revalidate, just update the status\n  const onOffline = () => {\n    online = false;\n  };\n  onWindowEvent('online', onOnline);\n  onWindowEvent('offline', onOffline);\n  return () => {\n    offWindowEvent('online', onOnline);\n    offWindowEvent('offline', onOffline);\n  };\n};\nconst preset = {\n  isOnline,\n  isVisible\n};\nconst defaultConfigOptions = {\n  initFocus,\n  initReconnect\n};\nconst IS_REACT_LEGACY = !React.useId;\nconst IS_SERVER = !isWindowDefined || 'Deno' in window;\n// Polyfill requestAnimationFrame\nconst rAF = f => hasRequestAnimationFrame() ? window['requestAnimationFrame'](f) : setTimeout(f, 1);\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nconst useIsomorphicLayoutEffect = IS_SERVER ? useEffect : useLayoutEffect;\n// This assignment is to extend the Navigator type to use effectiveType.\nconst navigatorConnection = typeof navigator !== 'undefined' && navigator.connection;\n// Adjust the config based on slow connection status (<= 70Kbps).\nconst slowConnection = !IS_SERVER && navigatorConnection && (['slow-2g', '2g'].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);\nconst serialize = key => {\n  if (isFunction(key)) {\n    try {\n      key = key();\n    } catch (err) {\n      // dependencies not ready\n      key = '';\n    }\n  }\n  // Use the original key as the argument of fetcher. This can be a string or an\n  // array of values.\n  const args = key;\n  // If key is not falsy, or not an empty array, hash it.\n  key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n  return [key, args];\n};\n\n// Global timestamp.\nlet __timestamp = 0;\nconst getTimestamp = () => ++__timestamp;\nconst FOCUS_EVENT = 0;\nconst RECONNECT_EVENT = 1;\nconst MUTATE_EVENT = 2;\nvar constants = {\n  __proto__: null,\n  FOCUS_EVENT: FOCUS_EVENT,\n  RECONNECT_EVENT: RECONNECT_EVENT,\n  MUTATE_EVENT: MUTATE_EVENT\n};\nasync function internalMutate() {\n  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n  const [cache, _key, _data, _opts] = args;\n  // When passing as a boolean, it's explicitly used to disable/enable\n  // revalidation.\n  const options = mergeObjects({\n    populateCache: true,\n    throwOnError: true\n  }, typeof _opts === 'boolean' ? {\n    revalidate: _opts\n  } : _opts || {});\n  let populateCache = options.populateCache;\n  const rollbackOnErrorOption = options.rollbackOnError;\n  let optimisticData = options.optimisticData;\n  const revalidate = options.revalidate !== false;\n  const rollbackOnError = error => {\n    return typeof rollbackOnErrorOption === 'function' ? rollbackOnErrorOption(error) : rollbackOnErrorOption !== false;\n  };\n  const throwOnError = options.throwOnError;\n  // If the second argument is a key filter, return the mutation results for all\n  // filtered keys.\n  if (isFunction(_key)) {\n    const keyFilter = _key;\n    const matchedKeys = [];\n    const it = cache.keys();\n    for (let keyIt = it.next(); !keyIt.done; keyIt = it.next()) {\n      const key = keyIt.value;\n      if (\n      // Skip the special useSWRInfinite keys.\n      !key.startsWith('$inf$') && keyFilter(cache.get(key)._k)) {\n        matchedKeys.push(key);\n      }\n    }\n    return Promise.all(matchedKeys.map(mutateByKey));\n  }\n  return mutateByKey(_key);\n  async function mutateByKey(_k) {\n    // Serialize key\n    const [key] = serialize(_k);\n    if (!key) return;\n    const [get, set] = createCacheHelper(cache, key);\n    const [EVENT_REVALIDATORS, MUTATION, FETCH] = SWRGlobalState.get(cache);\n    const revalidators = EVENT_REVALIDATORS[key];\n    const startRevalidate = () => {\n      if (revalidate) {\n        // Invalidate the key by deleting the concurrent request markers so new\n        // requests will not be deduped.\n        delete FETCH[key];\n        if (revalidators && revalidators[0]) {\n          return revalidators[0](MUTATE_EVENT).then(() => get().data);\n        }\n      }\n      return get().data;\n    };\n    // If there is no new data provided, revalidate the key with current state.\n    if (args.length < 3) {\n      // Revalidate and broadcast state.\n      return startRevalidate();\n    }\n    let data = _data;\n    let error;\n    // Update global timestamps.\n    const beforeMutationTs = getTimestamp();\n    MUTATION[key] = [beforeMutationTs, 0];\n    const hasOptimisticData = !isUndefined(optimisticData);\n    const state = get();\n    // `displayedData` is the current value on screen. It could be the optimistic value\n    // that is going to be overridden by a `committedData`, or get reverted back.\n    // `committedData` is the validated value that comes from a fetch or mutation.\n    const displayedData = state.data;\n    const currentData = state._c;\n    const committedData = isUndefined(currentData) ? displayedData : currentData;\n    // Do optimistic data update.\n    if (hasOptimisticData) {\n      optimisticData = isFunction(optimisticData) ? optimisticData(committedData) : optimisticData;\n      // When we set optimistic data, backup the current committedData data in `_c`.\n      set({\n        data: optimisticData,\n        _c: committedData\n      });\n    }\n    if (isFunction(data)) {\n      // `data` is a function, call it passing current cache value.\n      try {\n        data = data(committedData);\n      } catch (err) {\n        // If it throws an error synchronously, we shouldn't update the cache.\n        error = err;\n      }\n    }\n    // `data` is a promise/thenable, resolve the final data first.\n    if (data && isFunction(data.then)) {\n      // This means that the mutation is async, we need to check timestamps to\n      // avoid race conditions.\n      data = await data.catch(err => {\n        error = err;\n      });\n      // Check if other mutations have occurred since we've started this mutation.\n      // If there's a race we don't update cache or broadcast the change,\n      // just return the data.\n      if (beforeMutationTs !== MUTATION[key][0]) {\n        if (error) throw error;\n        return data;\n      } else if (error && hasOptimisticData && rollbackOnError(error)) {\n        // Rollback. Always populate the cache in this case but without\n        // transforming the data.\n        populateCache = true;\n        data = committedData;\n        // Reset data to be the latest committed data, and clear the `_c` value.\n        set({\n          data,\n          _c: UNDEFINED\n        });\n      }\n    }\n    // If we should write back the cache after request.\n    if (populateCache) {\n      if (!error) {\n        // Transform the result into data.\n        if (isFunction(populateCache)) {\n          data = populateCache(data, committedData);\n        }\n        // Only update cached data if there's no error. Data can be `undefined` here.\n        set({\n          data,\n          _c: UNDEFINED\n        });\n      }\n    }\n    // Reset the timestamp to mark the mutation has ended.\n    MUTATION[key][1] = getTimestamp();\n    // Update existing SWR Hooks' internal states:\n    const res = await startRevalidate();\n    // The mutation and revalidation are ended, we can clear it since the data is\n    // not an optimistic value anymore.\n    set({\n      _c: UNDEFINED\n    });\n    // Throw error or return data\n    if (error) {\n      if (throwOnError) throw error;\n      return;\n    }\n    return populateCache ? res : data;\n  }\n}\nconst revalidateAllKeys = (revalidators, type) => {\n  for (const key in revalidators) {\n    if (revalidators[key][0]) revalidators[key][0](type);\n  }\n};\nconst initCache = (provider, options) => {\n  // The global state for a specific provider will be used to deduplicate\n  // requests and store listeners. As well as a mutate function that is bound to\n  // the cache.\n  // The provider's global state might be already initialized. Let's try to get the\n  // global state associated with the provider first.\n  if (!SWRGlobalState.has(provider)) {\n    const opts = mergeObjects(defaultConfigOptions, options);\n    // If there's no global state bound to the provider, create a new one with the\n    // new mutate function.\n    const EVENT_REVALIDATORS = {};\n    const mutate = internalMutate.bind(UNDEFINED, provider);\n    let unmount = noop;\n    const subscriptions = {};\n    const subscribe = (key, callback) => {\n      const subs = subscriptions[key] || [];\n      subscriptions[key] = subs;\n      subs.push(callback);\n      return () => subs.splice(subs.indexOf(callback), 1);\n    };\n    const setter = (key, value, prev) => {\n      provider.set(key, value);\n      const subs = subscriptions[key];\n      if (subs) {\n        for (let i = subs.length; i--;) {\n          subs[i](prev, value);\n        }\n      }\n    };\n    const initProvider = () => {\n      if (!SWRGlobalState.has(provider)) {\n        // Update the state if it's new, or if the provider has been extended.\n        SWRGlobalState.set(provider, [EVENT_REVALIDATORS, {}, {}, {}, mutate, setter, subscribe]);\n        if (!IS_SERVER) {\n          // When listening to the native events for auto revalidations,\n          // we intentionally put a delay (setTimeout) here to make sure they are\n          // fired after immediate JavaScript executions, which can be\n          // React's state updates.\n          // This avoids some unnecessary revalidations such as\n          // https://github.com/vercel/swr/issues/1680.\n          const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));\n          const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));\n          unmount = () => {\n            releaseFocus && releaseFocus();\n            releaseReconnect && releaseReconnect();\n            // When un-mounting, we need to remove the cache provider from the state\n            // storage too because it's a side-effect. Otherwise, when re-mounting we\n            // will not re-register those event listeners.\n            SWRGlobalState.delete(provider);\n          };\n        }\n      }\n    };\n    initProvider();\n    // This is a new provider, we need to initialize it and setup DOM events\n    // listeners for `focus` and `reconnect` actions.\n    // We might want to inject an extra layer on top of `provider` in the future,\n    // such as key serialization, auto GC, etc.\n    // For now, it's just a `Map` interface without any modifications.\n    return [provider, mutate, initProvider, unmount];\n  }\n  return [provider, SWRGlobalState.get(provider)[4]];\n};\n\n// error retry\nconst onErrorRetry = (_, __, config, revalidate, opts) => {\n  const maxRetryCount = config.errorRetryCount;\n  const currentRetryCount = opts.retryCount;\n  // Exponential backoff\n  const timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n  if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n    return;\n  }\n  setTimeout(revalidate, timeout, opts);\n};\nconst compare = (currentData, newData) => stableHash(currentData) == stableHash(newData);\n// Default cache provider\nconst [cache, mutate] = initCache(new Map());\n// Default config\nconst defaultConfig = mergeObjects({\n  // events\n  onLoadingSlow: noop,\n  onSuccess: noop,\n  onError: noop,\n  onErrorRetry,\n  onDiscarded: noop,\n  // switches\n  revalidateOnFocus: true,\n  revalidateOnReconnect: true,\n  revalidateIfStale: true,\n  shouldRetryOnError: true,\n  // timeouts\n  errorRetryInterval: slowConnection ? 10000 : 5000,\n  focusThrottleInterval: 5 * 1000,\n  dedupingInterval: 2 * 1000,\n  loadingTimeout: slowConnection ? 5000 : 3000,\n  // providers\n  compare,\n  isPaused: () => false,\n  cache,\n  mutate,\n  fallback: {}\n},\n// use web preset by default\npreset);\nconst mergeConfigs = (a, b) => {\n  // Need to create a new object to avoid mutating the original here.\n  const v = mergeObjects(a, b);\n  // If two configs are provided, merge their `use` and `fallback` options.\n  if (b) {\n    const {\n      use: u1,\n      fallback: f1\n    } = a;\n    const {\n      use: u2,\n      fallback: f2\n    } = b;\n    if (u1 && u2) {\n      v.use = u1.concat(u2);\n    }\n    if (f1 && f2) {\n      v.fallback = mergeObjects(f1, f2);\n    }\n  }\n  return v;\n};\nconst SWRConfigContext = createContext({});\nconst SWRConfig = props => {\n  const {\n    value\n  } = props;\n  const parentConfig = useContext(SWRConfigContext);\n  const isFunctionalConfig = isFunction(value);\n  const config = useMemo(() => isFunctionalConfig ? value(parentConfig) : value, [isFunctionalConfig, parentConfig, value]);\n  // Extend parent context values and middleware.\n  const extendedConfig = useMemo(() => isFunctionalConfig ? config : mergeConfigs(parentConfig, config), [isFunctionalConfig, parentConfig, config]);\n  // Should not use the inherited provider.\n  const provider = config && config.provider;\n  // Use a lazy initialized state to create the cache on first access.\n  const [cacheContext] = useState(() => provider ? initCache(provider(extendedConfig.cache || cache), config) : UNDEFINED);\n  // Override the cache if a new provider is given.\n  if (cacheContext) {\n    extendedConfig.cache = cacheContext[0];\n    extendedConfig.mutate = cacheContext[1];\n  }\n  // Unsubscribe events.\n  useIsomorphicLayoutEffect(() => {\n    if (cacheContext) {\n      cacheContext[2] && cacheContext[2]();\n      return cacheContext[3];\n    }\n  }, []);\n  return createElement(SWRConfigContext.Provider, mergeObjects(props, {\n    value: extendedConfig\n  }));\n};\n\n// @ts-expect-error\nconst enableDevtools = isWindowDefined && window.__SWR_DEVTOOLS_USE__;\nconst use = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [];\nconst setupDevTools = () => {\n  if (enableDevtools) {\n    // @ts-expect-error\n    window.__SWR_DEVTOOLS_REACT__ = React;\n  }\n};\nconst normalize = args => {\n  return isFunction(args[1]) ? [args[0], args[1], args[2] || {}] : [args[0], null, (args[1] === null ? args[2] : args[1]) || {}];\n};\nconst useSWRConfig = () => {\n  return mergeObjects(defaultConfig, useContext(SWRConfigContext));\n};\nconst preload = (key_, fetcher) => {\n  const key = serialize(key_)[0];\n  const [,,, PRELOAD] = SWRGlobalState.get(cache);\n  // Prevent preload to be called multiple times before used.\n  if (PRELOAD[key]) return PRELOAD[key];\n  const req = fetcher(key_);\n  PRELOAD[key] = req;\n  return req;\n};\nconst middleware = useSWRNext => (key_, fetcher_, config) => {\n  // fetcher might be a sync function, so this should not be an async function\n  const fetcher = fetcher_ && function () {\n    const key = serialize(key_)[0];\n    const [,,, PRELOAD] = SWRGlobalState.get(cache);\n    const req = PRELOAD[key];\n    if (req) {\n      delete PRELOAD[key];\n      return req;\n    }\n    return fetcher_(...arguments);\n  };\n  return useSWRNext(key_, fetcher, config);\n};\nconst BUILT_IN_MIDDLEWARE = use.concat(middleware);\n\n// It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\nconst withArgs = hook => {\n  return function useSWRArgs() {\n    // Get the default and inherited configuration.\n    const fallbackConfig = useSWRConfig();\n    // Normalize arguments.\n    for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    const [key, fn, _config] = normalize(args);\n    // Merge configurations.\n    const config = mergeConfigs(fallbackConfig, _config);\n    // Apply middleware\n    let next = hook;\n    const {\n      use\n    } = config;\n    const middleware = (use || []).concat(BUILT_IN_MIDDLEWARE);\n    for (let i = middleware.length; i--;) {\n      next = middleware[i](next);\n    }\n    return next(key, fn || config.fetcher || null, config);\n  };\n};\n\n/**\n * An implementation of state with dependency-tracking.\n */\nconst useStateWithDeps = state => {\n  const rerender = useState({})[1];\n  const unmountedRef = useRef(false);\n  const stateRef = useRef(state);\n  // If a state property (data, error, or isValidating) is accessed by the render\n  // function, we mark the property as a dependency so if it is updated again\n  // in the future, we trigger a rerender.\n  // This is also known as dependency-tracking.\n  const stateDependenciesRef = useRef({\n    data: false,\n    error: false,\n    isValidating: false\n  });\n  /**\n  * @param payload To change stateRef, pass the values explicitly to setState:\n  * @example\n  * ```js\n  * setState({\n  *   isValidating: false\n  *   data: newData // set data to newData\n  *   error: undefined // set error to undefined\n  * })\n  *\n  * setState({\n  *   isValidating: false\n  *   data: undefined // set data to undefined\n  *   error: err // set error to err\n  * })\n  * ```\n  */\n  const setState = useCallback(payload => {\n    let shouldRerender = false;\n    const currentState = stateRef.current;\n    for (const _ in payload) {\n      const k = _;\n      // If the property has changed, update the state and mark rerender as\n      // needed.\n      if (currentState[k] !== payload[k]) {\n        currentState[k] = payload[k];\n        // If the property is accessed by the component, a rerender should be\n        // triggered.\n        if (stateDependenciesRef.current[k]) {\n          shouldRerender = true;\n        }\n      }\n    }\n    if (shouldRerender && !unmountedRef.current) {\n      if (IS_REACT_LEGACY) {\n        rerender({});\n      } else {\n        React.startTransition(() => rerender({}));\n      }\n    }\n  },\n  // config.suspense isn't allowed to change during the lifecycle\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useIsomorphicLayoutEffect(() => {\n    unmountedRef.current = false;\n    return () => {\n      unmountedRef.current = true;\n    };\n  });\n  return [stateRef, stateDependenciesRef.current, setState];\n};\n\n// Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\nconst subscribeCallback = (key, callbacks, callback) => {\n  const keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n  keyedRevalidators.push(callback);\n  return () => {\n    const index = keyedRevalidators.indexOf(callback);\n    if (index >= 0) {\n      // O(1): faster than splice\n      keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n      keyedRevalidators.pop();\n    }\n  };\n};\n\n// Create a custom hook with a middleware\nconst withMiddleware = (useSWR, middleware) => {\n  return function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    const [key, fn, config] = normalize(args);\n    const uses = (config.use || []).concat(middleware);\n    return useSWR(key, fn, {\n      ...config,\n      use: uses\n    });\n  };\n};\nsetupDevTools();\nexport { IS_REACT_LEGACY, IS_SERVER, OBJECT, SWRConfig, SWRGlobalState, UNDEFINED, cache, compare, createCacheHelper, defaultConfig, defaultConfigOptions, getTimestamp, hasRequestAnimationFrame, initCache, internalMutate, isDocumentDefined, isFunction, isUndefined, isWindowDefined, mergeConfigs, mergeObjects, mutate, noop, normalize, preload, preset, rAF, constants as revalidateEvents, serialize, slowConnection, stableHash, subscribeCallback, useIsomorphicLayoutEffect, useSWRConfig, useStateWithDeps, withArgs, withMiddleware };","map":{"version":3,"names":["React","useEffect","useLayoutEffect","createContext","useContext","useMemo","useState","createElement","useRef","useCallback","SWRGlobalState","WeakMap","EMPTY_CACHE","noop","UNDEFINED","OBJECT","Object","isUndefined","v","isFunction","mergeObjects","a","b","STR_UNDEFINED","isWindowDefined","window","isDocumentDefined","document","hasRequestAnimationFrame","createCacheHelper","cache","key","state","get","info","prev","table","counter","stableHash","arg","type","constructor","isDate","Date","result","index","RegExp","set","Array","length","keys","sort","pop","toJSON","toString","JSON","stringify","online","isOnline","onWindowEvent","offWindowEvent","addEventListener","bind","removeEventListener","isVisible","visibilityState","initFocus","callback","initReconnect","onOnline","onOffline","preset","defaultConfigOptions","IS_REACT_LEGACY","useId","IS_SERVER","rAF","f","setTimeout","useIsomorphicLayoutEffect","navigatorConnection","navigator","connection","slowConnection","includes","effectiveType","saveData","serialize","err","args","isArray","__timestamp","getTimestamp","FOCUS_EVENT","RECONNECT_EVENT","MUTATE_EVENT","constants","__proto__","internalMutate","_key","_data","_opts","options","populateCache","throwOnError","revalidate","rollbackOnErrorOption","rollbackOnError","optimisticData","error","keyFilter","matchedKeys","it","keyIt","next","done","value","startsWith","_k","push","Promise","all","map","mutateByKey","EVENT_REVALIDATORS","MUTATION","FETCH","revalidators","startRevalidate","then","data","beforeMutationTs","hasOptimisticData","displayedData","currentData","_c","committedData","catch","res","revalidateAllKeys","initCache","provider","has","opts","mutate","unmount","subscriptions","subscribe","subs","splice","indexOf","setter","i","initProvider","releaseFocus","releaseReconnect","delete","onErrorRetry","_","__","config","maxRetryCount","errorRetryCount","currentRetryCount","retryCount","timeout","Math","random","errorRetryInterval","compare","newData","Map","defaultConfig","onLoadingSlow","onSuccess","onError","onDiscarded","revalidateOnFocus","revalidateOnReconnect","revalidateIfStale","shouldRetryOnError","focusThrottleInterval","dedupingInterval","loadingTimeout","isPaused","fallback","mergeConfigs","use","u1","f1","u2","f2","concat","SWRConfigContext","SWRConfig","props","parentConfig","isFunctionalConfig","extendedConfig","cacheContext","Provider","enableDevtools","__SWR_DEVTOOLS_USE__","setupDevTools","__SWR_DEVTOOLS_REACT__","normalize","useSWRConfig","preload","key_","fetcher","PRELOAD","req","middleware","useSWRNext","fetcher_","BUILT_IN_MIDDLEWARE","withArgs","hook","useSWRArgs","fallbackConfig","fn","_config","useStateWithDeps","rerender","unmountedRef","stateRef","stateDependenciesRef","isValidating","setState","payload","shouldRerender","currentState","current","k","startTransition","subscribeCallback","callbacks","keyedRevalidators","withMiddleware","useSWR","uses","revalidateEvents"],"sources":["/Users/daotoanthang/Documents/Front End/REACT/react-simple-movies/node_modules/swr/_internal/dist/index.mjs"],"sourcesContent":["import React, { useEffect, useLayoutEffect, createContext, useContext, useMemo, useState, createElement, useRef, useCallback } from 'react';\n\n// Global state used to deduplicate requests and store listeners\nconst SWRGlobalState = new WeakMap();\n\nconst EMPTY_CACHE = {};\nconst noop = ()=>{};\n// Using noop() as the undefined value as undefined can be replaced\n// by something else. Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nconst UNDEFINED = /*#__NOINLINE__*/ noop();\nconst OBJECT = Object;\nconst isUndefined = (v)=>v === UNDEFINED;\nconst isFunction = (v)=>typeof v == 'function';\nconst mergeObjects = (a, b)=>({\n        ...a,\n        ...b\n    });\nconst STR_UNDEFINED = 'undefined';\n// NOTE: Use the function to guarantee it's re-evaluated between jsdom and node runtime for tests.\nconst isWindowDefined = typeof window != STR_UNDEFINED;\nconst isDocumentDefined = typeof document != STR_UNDEFINED;\nconst hasRequestAnimationFrame = ()=>isWindowDefined && typeof window['requestAnimationFrame'] != STR_UNDEFINED;\nconst createCacheHelper = (cache, key)=>{\n    const state = SWRGlobalState.get(cache);\n    return [\n        // Getter\n        ()=>cache.get(key) || EMPTY_CACHE,\n        // Setter\n        (info)=>{\n            const prev = cache.get(key);\n            state[5](key, mergeObjects(prev, info), prev || EMPTY_CACHE);\n        },\n        // Subscriber\n        state[6]\n    ];\n};\n\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nconst table = new WeakMap();\n// counter of the key\nlet counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\nconst stableHash = (arg)=>{\n    const type = typeof arg;\n    const constructor = arg && arg.constructor;\n    const isDate = constructor == Date;\n    let result;\n    let index;\n    if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {\n        // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n        // If it's already hashed, directly return the result.\n        result = table.get(arg);\n        if (result) return result;\n        // Store the hash first for circular reference detection before entering the\n        // recursive `stableHash` calls.\n        // For other objects like set and map, we use this id directly as the hash.\n        result = ++counter + '~';\n        table.set(arg, result);\n        if (constructor == Array) {\n            // Array.\n            result = '@';\n            for(index = 0; index < arg.length; index++){\n                result += stableHash(arg[index]) + ',';\n            }\n            table.set(arg, result);\n        }\n        if (constructor == OBJECT) {\n            // Object, sort keys.\n            result = '#';\n            const keys = OBJECT.keys(arg).sort();\n            while(!isUndefined(index = keys.pop())){\n                if (!isUndefined(arg[index])) {\n                    result += index + ':' + stableHash(arg[index]) + ',';\n                }\n            }\n            table.set(arg, result);\n        }\n    } else {\n        result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n    }\n    return result;\n};\n\n/**\n * Due to the bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\n * it's not reliable to detect if the browser is currently online or offline\n * based on `navigator.onLine`.\n * As a workaround, we always assume it's online on the first load, and change\n * the status upon `online` or `offline` events.\n */ let online = true;\nconst isOnline = ()=>online;\n// For node and React Native, `add/removeEventListener` doesn't exist on window.\nconst [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [\n    window.addEventListener.bind(window),\n    window.removeEventListener.bind(window)\n] : [\n    noop,\n    noop\n];\nconst isVisible = ()=>{\n    const visibilityState = isDocumentDefined && document.visibilityState;\n    return isUndefined(visibilityState) || visibilityState !== 'hidden';\n};\nconst initFocus = (callback)=>{\n    // focus revalidate\n    if (isDocumentDefined) {\n        document.addEventListener('visibilitychange', callback);\n    }\n    onWindowEvent('focus', callback);\n    return ()=>{\n        if (isDocumentDefined) {\n            document.removeEventListener('visibilitychange', callback);\n        }\n        offWindowEvent('focus', callback);\n    };\n};\nconst initReconnect = (callback)=>{\n    // revalidate on reconnected\n    const onOnline = ()=>{\n        online = true;\n        callback();\n    };\n    // nothing to revalidate, just update the status\n    const onOffline = ()=>{\n        online = false;\n    };\n    onWindowEvent('online', onOnline);\n    onWindowEvent('offline', onOffline);\n    return ()=>{\n        offWindowEvent('online', onOnline);\n        offWindowEvent('offline', onOffline);\n    };\n};\nconst preset = {\n    isOnline,\n    isVisible\n};\nconst defaultConfigOptions = {\n    initFocus,\n    initReconnect\n};\n\nconst IS_REACT_LEGACY = !React.useId;\nconst IS_SERVER = !isWindowDefined || 'Deno' in window;\n// Polyfill requestAnimationFrame\nconst rAF = (f)=>hasRequestAnimationFrame() ? window['requestAnimationFrame'](f) : setTimeout(f, 1);\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nconst useIsomorphicLayoutEffect = IS_SERVER ? useEffect : useLayoutEffect;\n// This assignment is to extend the Navigator type to use effectiveType.\nconst navigatorConnection = typeof navigator !== 'undefined' && navigator.connection;\n// Adjust the config based on slow connection status (<= 70Kbps).\nconst slowConnection = !IS_SERVER && navigatorConnection && ([\n    'slow-2g',\n    '2g'\n].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);\n\nconst serialize = (key)=>{\n    if (isFunction(key)) {\n        try {\n            key = key();\n        } catch (err) {\n            // dependencies not ready\n            key = '';\n        }\n    }\n    // Use the original key as the argument of fetcher. This can be a string or an\n    // array of values.\n    const args = key;\n    // If key is not falsy, or not an empty array, hash it.\n    key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n    return [\n        key,\n        args\n    ];\n};\n\n// Global timestamp.\nlet __timestamp = 0;\nconst getTimestamp = ()=>++__timestamp;\n\nconst FOCUS_EVENT = 0;\nconst RECONNECT_EVENT = 1;\nconst MUTATE_EVENT = 2;\n\nvar constants = {\n  __proto__: null,\n  FOCUS_EVENT: FOCUS_EVENT,\n  RECONNECT_EVENT: RECONNECT_EVENT,\n  MUTATE_EVENT: MUTATE_EVENT\n};\n\nasync function internalMutate(...args) {\n    const [cache, _key, _data, _opts] = args;\n    // When passing as a boolean, it's explicitly used to disable/enable\n    // revalidation.\n    const options = mergeObjects({\n        populateCache: true,\n        throwOnError: true\n    }, typeof _opts === 'boolean' ? {\n        revalidate: _opts\n    } : _opts || {});\n    let populateCache = options.populateCache;\n    const rollbackOnErrorOption = options.rollbackOnError;\n    let optimisticData = options.optimisticData;\n    const revalidate = options.revalidate !== false;\n    const rollbackOnError = (error)=>{\n        return typeof rollbackOnErrorOption === 'function' ? rollbackOnErrorOption(error) : rollbackOnErrorOption !== false;\n    };\n    const throwOnError = options.throwOnError;\n    // If the second argument is a key filter, return the mutation results for all\n    // filtered keys.\n    if (isFunction(_key)) {\n        const keyFilter = _key;\n        const matchedKeys = [];\n        const it = cache.keys();\n        for(let keyIt = it.next(); !keyIt.done; keyIt = it.next()){\n            const key = keyIt.value;\n            if (// Skip the special useSWRInfinite keys.\n            !key.startsWith('$inf$') && keyFilter(cache.get(key)._k)) {\n                matchedKeys.push(key);\n            }\n        }\n        return Promise.all(matchedKeys.map(mutateByKey));\n    }\n    return mutateByKey(_key);\n    async function mutateByKey(_k) {\n        // Serialize key\n        const [key] = serialize(_k);\n        if (!key) return;\n        const [get, set] = createCacheHelper(cache, key);\n        const [EVENT_REVALIDATORS, MUTATION, FETCH] = SWRGlobalState.get(cache);\n        const revalidators = EVENT_REVALIDATORS[key];\n        const startRevalidate = ()=>{\n            if (revalidate) {\n                // Invalidate the key by deleting the concurrent request markers so new\n                // requests will not be deduped.\n                delete FETCH[key];\n                if (revalidators && revalidators[0]) {\n                    return revalidators[0](MUTATE_EVENT).then(()=>get().data);\n                }\n            }\n            return get().data;\n        };\n        // If there is no new data provided, revalidate the key with current state.\n        if (args.length < 3) {\n            // Revalidate and broadcast state.\n            return startRevalidate();\n        }\n        let data = _data;\n        let error;\n        // Update global timestamps.\n        const beforeMutationTs = getTimestamp();\n        MUTATION[key] = [\n            beforeMutationTs,\n            0\n        ];\n        const hasOptimisticData = !isUndefined(optimisticData);\n        const state = get();\n        // `displayedData` is the current value on screen. It could be the optimistic value\n        // that is going to be overridden by a `committedData`, or get reverted back.\n        // `committedData` is the validated value that comes from a fetch or mutation.\n        const displayedData = state.data;\n        const currentData = state._c;\n        const committedData = isUndefined(currentData) ? displayedData : currentData;\n        // Do optimistic data update.\n        if (hasOptimisticData) {\n            optimisticData = isFunction(optimisticData) ? optimisticData(committedData) : optimisticData;\n            // When we set optimistic data, backup the current committedData data in `_c`.\n            set({\n                data: optimisticData,\n                _c: committedData\n            });\n        }\n        if (isFunction(data)) {\n            // `data` is a function, call it passing current cache value.\n            try {\n                data = data(committedData);\n            } catch (err) {\n                // If it throws an error synchronously, we shouldn't update the cache.\n                error = err;\n            }\n        }\n        // `data` is a promise/thenable, resolve the final data first.\n        if (data && isFunction(data.then)) {\n            // This means that the mutation is async, we need to check timestamps to\n            // avoid race conditions.\n            data = await data.catch((err)=>{\n                error = err;\n            });\n            // Check if other mutations have occurred since we've started this mutation.\n            // If there's a race we don't update cache or broadcast the change,\n            // just return the data.\n            if (beforeMutationTs !== MUTATION[key][0]) {\n                if (error) throw error;\n                return data;\n            } else if (error && hasOptimisticData && rollbackOnError(error)) {\n                // Rollback. Always populate the cache in this case but without\n                // transforming the data.\n                populateCache = true;\n                data = committedData;\n                // Reset data to be the latest committed data, and clear the `_c` value.\n                set({\n                    data,\n                    _c: UNDEFINED\n                });\n            }\n        }\n        // If we should write back the cache after request.\n        if (populateCache) {\n            if (!error) {\n                // Transform the result into data.\n                if (isFunction(populateCache)) {\n                    data = populateCache(data, committedData);\n                }\n                // Only update cached data if there's no error. Data can be `undefined` here.\n                set({\n                    data,\n                    _c: UNDEFINED\n                });\n            }\n        }\n        // Reset the timestamp to mark the mutation has ended.\n        MUTATION[key][1] = getTimestamp();\n        // Update existing SWR Hooks' internal states:\n        const res = await startRevalidate();\n        // The mutation and revalidation are ended, we can clear it since the data is\n        // not an optimistic value anymore.\n        set({\n            _c: UNDEFINED\n        });\n        // Throw error or return data\n        if (error) {\n            if (throwOnError) throw error;\n            return;\n        }\n        return populateCache ? res : data;\n    }\n}\n\nconst revalidateAllKeys = (revalidators, type)=>{\n    for(const key in revalidators){\n        if (revalidators[key][0]) revalidators[key][0](type);\n    }\n};\nconst initCache = (provider, options)=>{\n    // The global state for a specific provider will be used to deduplicate\n    // requests and store listeners. As well as a mutate function that is bound to\n    // the cache.\n    // The provider's global state might be already initialized. Let's try to get the\n    // global state associated with the provider first.\n    if (!SWRGlobalState.has(provider)) {\n        const opts = mergeObjects(defaultConfigOptions, options);\n        // If there's no global state bound to the provider, create a new one with the\n        // new mutate function.\n        const EVENT_REVALIDATORS = {};\n        const mutate = internalMutate.bind(UNDEFINED, provider);\n        let unmount = noop;\n        const subscriptions = {};\n        const subscribe = (key, callback)=>{\n            const subs = subscriptions[key] || [];\n            subscriptions[key] = subs;\n            subs.push(callback);\n            return ()=>subs.splice(subs.indexOf(callback), 1);\n        };\n        const setter = (key, value, prev)=>{\n            provider.set(key, value);\n            const subs = subscriptions[key];\n            if (subs) {\n                for(let i = subs.length; i--;){\n                    subs[i](prev, value);\n                }\n            }\n        };\n        const initProvider = ()=>{\n            if (!SWRGlobalState.has(provider)) {\n                // Update the state if it's new, or if the provider has been extended.\n                SWRGlobalState.set(provider, [\n                    EVENT_REVALIDATORS,\n                    {},\n                    {},\n                    {},\n                    mutate,\n                    setter,\n                    subscribe\n                ]);\n                if (!IS_SERVER) {\n                    // When listening to the native events for auto revalidations,\n                    // we intentionally put a delay (setTimeout) here to make sure they are\n                    // fired after immediate JavaScript executions, which can be\n                    // React's state updates.\n                    // This avoids some unnecessary revalidations such as\n                    // https://github.com/vercel/swr/issues/1680.\n                    const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));\n                    const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));\n                    unmount = ()=>{\n                        releaseFocus && releaseFocus();\n                        releaseReconnect && releaseReconnect();\n                        // When un-mounting, we need to remove the cache provider from the state\n                        // storage too because it's a side-effect. Otherwise, when re-mounting we\n                        // will not re-register those event listeners.\n                        SWRGlobalState.delete(provider);\n                    };\n                }\n            }\n        };\n        initProvider();\n        // This is a new provider, we need to initialize it and setup DOM events\n        // listeners for `focus` and `reconnect` actions.\n        // We might want to inject an extra layer on top of `provider` in the future,\n        // such as key serialization, auto GC, etc.\n        // For now, it's just a `Map` interface without any modifications.\n        return [\n            provider,\n            mutate,\n            initProvider,\n            unmount\n        ];\n    }\n    return [\n        provider,\n        SWRGlobalState.get(provider)[4]\n    ];\n};\n\n// error retry\nconst onErrorRetry = (_, __, config, revalidate, opts)=>{\n    const maxRetryCount = config.errorRetryCount;\n    const currentRetryCount = opts.retryCount;\n    // Exponential backoff\n    const timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n    if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n        return;\n    }\n    setTimeout(revalidate, timeout, opts);\n};\nconst compare = (currentData, newData)=>stableHash(currentData) == stableHash(newData);\n// Default cache provider\nconst [cache, mutate] = initCache(new Map());\n// Default config\nconst defaultConfig = mergeObjects({\n    // events\n    onLoadingSlow: noop,\n    onSuccess: noop,\n    onError: noop,\n    onErrorRetry,\n    onDiscarded: noop,\n    // switches\n    revalidateOnFocus: true,\n    revalidateOnReconnect: true,\n    revalidateIfStale: true,\n    shouldRetryOnError: true,\n    // timeouts\n    errorRetryInterval: slowConnection ? 10000 : 5000,\n    focusThrottleInterval: 5 * 1000,\n    dedupingInterval: 2 * 1000,\n    loadingTimeout: slowConnection ? 5000 : 3000,\n    // providers\n    compare,\n    isPaused: ()=>false,\n    cache,\n    mutate,\n    fallback: {}\n}, // use web preset by default\npreset);\n\nconst mergeConfigs = (a, b)=>{\n    // Need to create a new object to avoid mutating the original here.\n    const v = mergeObjects(a, b);\n    // If two configs are provided, merge their `use` and `fallback` options.\n    if (b) {\n        const { use: u1 , fallback: f1  } = a;\n        const { use: u2 , fallback: f2  } = b;\n        if (u1 && u2) {\n            v.use = u1.concat(u2);\n        }\n        if (f1 && f2) {\n            v.fallback = mergeObjects(f1, f2);\n        }\n    }\n    return v;\n};\n\nconst SWRConfigContext = createContext({});\nconst SWRConfig = (props)=>{\n    const { value  } = props;\n    const parentConfig = useContext(SWRConfigContext);\n    const isFunctionalConfig = isFunction(value);\n    const config = useMemo(()=>isFunctionalConfig ? value(parentConfig) : value, [\n        isFunctionalConfig,\n        parentConfig,\n        value\n    ]);\n    // Extend parent context values and middleware.\n    const extendedConfig = useMemo(()=>isFunctionalConfig ? config : mergeConfigs(parentConfig, config), [\n        isFunctionalConfig,\n        parentConfig,\n        config\n    ]);\n    // Should not use the inherited provider.\n    const provider = config && config.provider;\n    // Use a lazy initialized state to create the cache on first access.\n    const [cacheContext] = useState(()=>provider ? initCache(provider(extendedConfig.cache || cache), config) : UNDEFINED);\n    // Override the cache if a new provider is given.\n    if (cacheContext) {\n        extendedConfig.cache = cacheContext[0];\n        extendedConfig.mutate = cacheContext[1];\n    }\n    // Unsubscribe events.\n    useIsomorphicLayoutEffect(()=>{\n        if (cacheContext) {\n            cacheContext[2] && cacheContext[2]();\n            return cacheContext[3];\n        }\n    }, []);\n    return createElement(SWRConfigContext.Provider, mergeObjects(props, {\n        value: extendedConfig\n    }));\n};\n\n// @ts-expect-error\nconst enableDevtools = isWindowDefined && window.__SWR_DEVTOOLS_USE__;\nconst use = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [];\nconst setupDevTools = ()=>{\n    if (enableDevtools) {\n        // @ts-expect-error\n        window.__SWR_DEVTOOLS_REACT__ = React;\n    }\n};\n\nconst normalize = (args)=>{\n    return isFunction(args[1]) ? [\n        args[0],\n        args[1],\n        args[2] || {}\n    ] : [\n        args[0],\n        null,\n        (args[1] === null ? args[2] : args[1]) || {}\n    ];\n};\n\nconst useSWRConfig = ()=>{\n    return mergeObjects(defaultConfig, useContext(SWRConfigContext));\n};\n\nconst preload = (key_, fetcher)=>{\n    const key = serialize(key_)[0];\n    const [, , , PRELOAD] = SWRGlobalState.get(cache);\n    // Prevent preload to be called multiple times before used.\n    if (PRELOAD[key]) return PRELOAD[key];\n    const req = fetcher(key_);\n    PRELOAD[key] = req;\n    return req;\n};\nconst middleware = (useSWRNext)=>(key_, fetcher_, config)=>{\n        // fetcher might be a sync function, so this should not be an async function\n        const fetcher = fetcher_ && ((...args)=>{\n            const key = serialize(key_)[0];\n            const [, , , PRELOAD] = SWRGlobalState.get(cache);\n            const req = PRELOAD[key];\n            if (req) {\n                delete PRELOAD[key];\n                return req;\n            }\n            return fetcher_(...args);\n        });\n        return useSWRNext(key_, fetcher, config);\n    };\n\nconst BUILT_IN_MIDDLEWARE = use.concat(middleware);\n\n// It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\nconst withArgs = (hook)=>{\n    return function useSWRArgs(...args) {\n        // Get the default and inherited configuration.\n        const fallbackConfig = useSWRConfig();\n        // Normalize arguments.\n        const [key, fn, _config] = normalize(args);\n        // Merge configurations.\n        const config = mergeConfigs(fallbackConfig, _config);\n        // Apply middleware\n        let next = hook;\n        const { use  } = config;\n        const middleware = (use || []).concat(BUILT_IN_MIDDLEWARE);\n        for(let i = middleware.length; i--;){\n            next = middleware[i](next);\n        }\n        return next(key, fn || config.fetcher || null, config);\n    };\n};\n\n/**\n * An implementation of state with dependency-tracking.\n */ const useStateWithDeps = (state)=>{\n    const rerender = useState({})[1];\n    const unmountedRef = useRef(false);\n    const stateRef = useRef(state);\n    // If a state property (data, error, or isValidating) is accessed by the render\n    // function, we mark the property as a dependency so if it is updated again\n    // in the future, we trigger a rerender.\n    // This is also known as dependency-tracking.\n    const stateDependenciesRef = useRef({\n        data: false,\n        error: false,\n        isValidating: false\n    });\n    /**\n   * @param payload To change stateRef, pass the values explicitly to setState:\n   * @example\n   * ```js\n   * setState({\n   *   isValidating: false\n   *   data: newData // set data to newData\n   *   error: undefined // set error to undefined\n   * })\n   *\n   * setState({\n   *   isValidating: false\n   *   data: undefined // set data to undefined\n   *   error: err // set error to err\n   * })\n   * ```\n   */ const setState = useCallback((payload)=>{\n        let shouldRerender = false;\n        const currentState = stateRef.current;\n        for(const _ in payload){\n            const k = _;\n            // If the property has changed, update the state and mark rerender as\n            // needed.\n            if (currentState[k] !== payload[k]) {\n                currentState[k] = payload[k];\n                // If the property is accessed by the component, a rerender should be\n                // triggered.\n                if (stateDependenciesRef.current[k]) {\n                    shouldRerender = true;\n                }\n            }\n        }\n        if (shouldRerender && !unmountedRef.current) {\n            if (IS_REACT_LEGACY) {\n                rerender({});\n            } else {\n                React.startTransition(()=>rerender({}));\n            }\n        }\n    }, // config.suspense isn't allowed to change during the lifecycle\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    useIsomorphicLayoutEffect(()=>{\n        unmountedRef.current = false;\n        return ()=>{\n            unmountedRef.current = true;\n        };\n    });\n    return [\n        stateRef,\n        stateDependenciesRef.current,\n        setState\n    ];\n};\n\n// Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\nconst subscribeCallback = (key, callbacks, callback)=>{\n    const keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n    keyedRevalidators.push(callback);\n    return ()=>{\n        const index = keyedRevalidators.indexOf(callback);\n        if (index >= 0) {\n            // O(1): faster than splice\n            keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n            keyedRevalidators.pop();\n        }\n    };\n};\n\n// Create a custom hook with a middleware\nconst withMiddleware = (useSWR, middleware)=>{\n    return (...args)=>{\n        const [key, fn, config] = normalize(args);\n        const uses = (config.use || []).concat(middleware);\n        return useSWR(key, fn, {\n            ...config,\n            use: uses\n        });\n    };\n};\n\nsetupDevTools();\n\nexport { IS_REACT_LEGACY, IS_SERVER, OBJECT, SWRConfig, SWRGlobalState, UNDEFINED, cache, compare, createCacheHelper, defaultConfig, defaultConfigOptions, getTimestamp, hasRequestAnimationFrame, initCache, internalMutate, isDocumentDefined, isFunction, isUndefined, isWindowDefined, mergeConfigs, mergeObjects, mutate, noop, normalize, preload, preset, rAF, constants as revalidateEvents, serialize, slowConnection, stableHash, subscribeCallback, useIsomorphicLayoutEffect, useSWRConfig, useStateWithDeps, withArgs, withMiddleware };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}