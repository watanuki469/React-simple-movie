{"ast":null,"code":"import { useRef, useCallback } from 'react';\nimport useSWR from 'swr';\nimport { withMiddleware, createCacheHelper, isUndefined, useIsomorphicLayoutEffect, serialize, UNDEFINED, isFunction } from 'swr/_internal';\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';\n\n// We have to several type castings here because `useSWRInfinite` is a special\nconst INFINITE_PREFIX = '$inf$';\nconst EMPTY_PROMISE = Promise.resolve();\nconst getFirstPageKey = getKey => {\n  return serialize(getKey ? getKey(0, null) : null)[0];\n};\nconst unstable_serialize = getKey => {\n  return INFINITE_PREFIX + getFirstPageKey(getKey);\n};\nconst infinite = useSWRNext => {\n  return (getKey, fn, config) => {\n    const didMountRef = useRef(false);\n    const dataRef = useRef();\n    const {\n      cache,\n      initialSize = 1,\n      revalidateAll = false,\n      persistSize = false,\n      revalidateFirstPage = true,\n      revalidateOnMount = false\n    } = config;\n    // The serialized key of the first page. This key will be used to store\n    // metadata of this SWR infinite hook.\n    let infiniteKey;\n    try {\n      infiniteKey = getFirstPageKey(getKey);\n      if (infiniteKey) infiniteKey = INFINITE_PREFIX + infiniteKey;\n    } catch (err) {\n      // Not ready yet.\n    }\n    const [get, set, subscribeCache] = createCacheHelper(cache, infiniteKey);\n    const getSnapshot = useCallback(() => {\n      const size = isUndefined(get()._l) ? initialSize : get()._l;\n      return size;\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [cache, infiniteKey, initialSize]);\n    useSyncExternalStore(useCallback(callback => {\n      if (infiniteKey) return subscribeCache(infiniteKey, () => {\n        callback();\n      });\n      return () => {};\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [cache, infiniteKey]), getSnapshot, getSnapshot);\n    const resolvePageSize = useCallback(() => {\n      const cachedPageSize = get()._l;\n      return isUndefined(cachedPageSize) ? initialSize : cachedPageSize;\n      // `cache` isn't allowed to change during the lifecycle\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [infiniteKey, initialSize]);\n    // keep the last page size to restore it with the persistSize option\n    const lastPageSizeRef = useRef(resolvePageSize());\n    // When the page key changes, we reset the page size if it's not persisted\n    useIsomorphicLayoutEffect(() => {\n      if (!didMountRef.current) {\n        didMountRef.current = true;\n        return;\n      }\n      if (infiniteKey) {\n        // If the key has been changed, we keep the current page size if persistSize is enabled\n        set({\n          _l: persistSize ? lastPageSizeRef.current : initialSize\n        });\n      }\n      // `initialSize` isn't allowed to change during the lifecycle\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [infiniteKey, cache]);\n    // Needs to check didMountRef during mounting, not in the fetcher\n    const shouldRevalidateOnMount = revalidateOnMount && !didMountRef.current;\n    // Actual SWR hook to load all pages in one fetcher.\n    const swr = useSWRNext(infiniteKey, async () => {\n      // get the revalidate context\n      const [forceRevalidateAll, originalData] = get()._i || [];\n      // return an array of page data\n      const data = [];\n      const pageSize = resolvePageSize();\n      let previousPageData = null;\n      for (let i = 0; i < pageSize; ++i) {\n        const [pageKey, pageArg] = serialize(getKey(i, previousPageData));\n        if (!pageKey) {\n          break;\n        }\n        const [getSWRCache, setSWRCache] = createCacheHelper(cache, pageKey);\n        // Get the cached page data.\n        let pageData = getSWRCache().data;\n        // should fetch (or revalidate) if:\n        // - `revalidateAll` is enabled\n        // - `mutate()` called\n        // - the cache is missing\n        // - it's the first page and it's not the initial render\n        // - `revalidateOnMount` is enabled and it's on mount\n        // - cache for that page has changed\n        const shouldFetchPage = revalidateAll || forceRevalidateAll || isUndefined(pageData) || revalidateFirstPage && !i && !isUndefined(dataRef.current) || shouldRevalidateOnMount || originalData && !isUndefined(originalData[i]) && !config.compare(originalData[i], pageData);\n        if (fn && shouldFetchPage) {\n          pageData = await fn(pageArg);\n          setSWRCache({\n            data: pageData,\n            _k: pageArg\n          });\n        }\n        data.push(pageData);\n        previousPageData = pageData;\n      }\n      // once we executed the data fetching based on the context, clear the context\n      set({\n        _i: UNDEFINED\n      });\n      // return the data\n      return data;\n    }, config);\n    // update dataRef\n    useIsomorphicLayoutEffect(() => {\n      dataRef.current = swr.data;\n    }, [swr.data]);\n    const mutate = useCallback(\n    // eslint-disable-next-line func-names\n    function (data, opts) {\n      // When passing as a boolean, it's explicitly used to disable/enable\n      // revalidation.\n      const options = typeof opts === 'boolean' ? {\n        revalidate: opts\n      } : opts || {};\n      // Default to true.\n      const shouldRevalidate = options.revalidate !== false;\n      // It is possible that the key is still falsy.\n      if (!infiniteKey) return EMPTY_PROMISE;\n      if (shouldRevalidate) {\n        if (!isUndefined(data)) {\n          // We only revalidate the pages that are changed\n          const originalData = dataRef.current;\n          set({\n            _i: [false, originalData]\n          });\n        } else {\n          // Calling `mutate()`, we revalidate all pages\n          set({\n            _i: [true]\n          });\n        }\n      }\n      return arguments.length ? swr.mutate(data, shouldRevalidate) : swr.mutate();\n    },\n    // swr.mutate is always the same reference\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [infiniteKey, cache]);\n    // Function to load pages data from the cache based on the page size.\n    const resolvePagesFromCache = pageSize => {\n      // return an array of page data\n      const data = [];\n      let previousPageData = null;\n      for (let i = 0; i < pageSize; ++i) {\n        var ref;\n        const [pageKey] = serialize(getKey(i, previousPageData));\n        // Get the cached page data.\n        const pageData = pageKey ? (ref = cache.get(pageKey)) == null ? void 0 : ref.data : UNDEFINED;\n        // Return the current data if we can't get it from the cache.\n        if (isUndefined(pageData)) return dataRef.current;\n        data.push(pageData);\n        previousPageData = pageData;\n      }\n      // Return the data\n      return data;\n    };\n    // Extend the SWR API\n    const setSize = useCallback(arg => {\n      // It is possible that the key is still falsy.\n      if (!infiniteKey) return EMPTY_PROMISE;\n      let size;\n      if (isFunction(arg)) {\n        size = arg(resolvePageSize());\n      } else if (typeof arg == 'number') {\n        size = arg;\n      }\n      if (typeof size != 'number') return EMPTY_PROMISE;\n      set({\n        _l: size\n      });\n      lastPageSizeRef.current = size;\n      return mutate(resolvePagesFromCache(size));\n    },\n    // `cache` and `rerender` isn't allowed to change during the lifecycle\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [infiniteKey, resolvePageSize, mutate, cache]);\n    // Use getter functions to avoid unnecessary re-renders caused by triggering\n    // all the getters of the returned swr object.\n    return {\n      size: resolvePageSize(),\n      setSize,\n      mutate,\n      get data() {\n        return swr.data;\n      },\n      get error() {\n        return swr.error;\n      },\n      get isValidating() {\n        return swr.isValidating;\n      },\n      get isLoading() {\n        return swr.isLoading;\n      }\n    };\n  };\n};\nvar index = withMiddleware(useSWR, infinite);\nexport { index as default, infinite, unstable_serialize };","map":{"version":3,"names":["useRef","useCallback","useSWR","withMiddleware","createCacheHelper","isUndefined","useIsomorphicLayoutEffect","serialize","UNDEFINED","isFunction","useSyncExternalStore","INFINITE_PREFIX","EMPTY_PROMISE","Promise","resolve","getFirstPageKey","getKey","unstable_serialize","infinite","useSWRNext","fn","config","didMountRef","dataRef","cache","initialSize","revalidateAll","persistSize","revalidateFirstPage","revalidateOnMount","infiniteKey","err","get","set","subscribeCache","getSnapshot","size","_l","callback","resolvePageSize","cachedPageSize","lastPageSizeRef","current","shouldRevalidateOnMount","swr","forceRevalidateAll","originalData","_i","data","pageSize","previousPageData","i","pageKey","pageArg","getSWRCache","setSWRCache","pageData","shouldFetchPage","compare","_k","push","mutate","opts","options","revalidate","shouldRevalidate","arguments","length","resolvePagesFromCache","ref","setSize","arg","error","isValidating","isLoading","index","default"],"sources":["/Users/daotoanthang/Documents/Front End/REACT/react-simple-movies/node_modules/swr/infinite/dist/index.mjs"],"sourcesContent":["import { useRef, useCallback } from 'react';\nimport useSWR from 'swr';\nimport { withMiddleware, createCacheHelper, isUndefined, useIsomorphicLayoutEffect, serialize, UNDEFINED, isFunction } from 'swr/_internal';\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';\n\n// We have to several type castings here because `useSWRInfinite` is a special\nconst INFINITE_PREFIX = '$inf$';\nconst EMPTY_PROMISE = Promise.resolve();\nconst getFirstPageKey = (getKey)=>{\n    return serialize(getKey ? getKey(0, null) : null)[0];\n};\nconst unstable_serialize = (getKey)=>{\n    return INFINITE_PREFIX + getFirstPageKey(getKey);\n};\nconst infinite = (useSWRNext)=>{\n    return (getKey, fn, config)=>{\n        const didMountRef = useRef(false);\n        const dataRef = useRef();\n        const { cache , initialSize =1 , revalidateAll =false , persistSize =false , revalidateFirstPage =true , revalidateOnMount =false  } = config;\n        // The serialized key of the first page. This key will be used to store\n        // metadata of this SWR infinite hook.\n        let infiniteKey;\n        try {\n            infiniteKey = getFirstPageKey(getKey);\n            if (infiniteKey) infiniteKey = INFINITE_PREFIX + infiniteKey;\n        } catch (err) {\n        // Not ready yet.\n        }\n        const [get, set, subscribeCache] = createCacheHelper(cache, infiniteKey);\n        const getSnapshot = useCallback(()=>{\n            const size = isUndefined(get()._l) ? initialSize : get()._l;\n            return size;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            cache,\n            infiniteKey,\n            initialSize\n        ]);\n        useSyncExternalStore(useCallback((callback)=>{\n            if (infiniteKey) return subscribeCache(infiniteKey, ()=>{\n                callback();\n            });\n            return ()=>{};\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            cache,\n            infiniteKey\n        ]), getSnapshot, getSnapshot);\n        const resolvePageSize = useCallback(()=>{\n            const cachedPageSize = get()._l;\n            return isUndefined(cachedPageSize) ? initialSize : cachedPageSize;\n        // `cache` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            initialSize\n        ]);\n        // keep the last page size to restore it with the persistSize option\n        const lastPageSizeRef = useRef(resolvePageSize());\n        // When the page key changes, we reset the page size if it's not persisted\n        useIsomorphicLayoutEffect(()=>{\n            if (!didMountRef.current) {\n                didMountRef.current = true;\n                return;\n            }\n            if (infiniteKey) {\n                // If the key has been changed, we keep the current page size if persistSize is enabled\n                set({\n                    _l: persistSize ? lastPageSizeRef.current : initialSize\n                });\n            }\n        // `initialSize` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            cache\n        ]);\n        // Needs to check didMountRef during mounting, not in the fetcher\n        const shouldRevalidateOnMount = revalidateOnMount && !didMountRef.current;\n        // Actual SWR hook to load all pages in one fetcher.\n        const swr = useSWRNext(infiniteKey, async ()=>{\n            // get the revalidate context\n            const [forceRevalidateAll, originalData] = get()._i || [];\n            // return an array of page data\n            const data = [];\n            const pageSize = resolvePageSize();\n            let previousPageData = null;\n            for(let i = 0; i < pageSize; ++i){\n                const [pageKey, pageArg] = serialize(getKey(i, previousPageData));\n                if (!pageKey) {\n                    break;\n                }\n                const [getSWRCache, setSWRCache] = createCacheHelper(cache, pageKey);\n                // Get the cached page data.\n                let pageData = getSWRCache().data;\n                // should fetch (or revalidate) if:\n                // - `revalidateAll` is enabled\n                // - `mutate()` called\n                // - the cache is missing\n                // - it's the first page and it's not the initial render\n                // - `revalidateOnMount` is enabled and it's on mount\n                // - cache for that page has changed\n                const shouldFetchPage = revalidateAll || forceRevalidateAll || isUndefined(pageData) || revalidateFirstPage && !i && !isUndefined(dataRef.current) || shouldRevalidateOnMount || originalData && !isUndefined(originalData[i]) && !config.compare(originalData[i], pageData);\n                if (fn && shouldFetchPage) {\n                    pageData = await fn(pageArg);\n                    setSWRCache({\n                        data: pageData,\n                        _k: pageArg\n                    });\n                }\n                data.push(pageData);\n                previousPageData = pageData;\n            }\n            // once we executed the data fetching based on the context, clear the context\n            set({\n                _i: UNDEFINED\n            });\n            // return the data\n            return data;\n        }, config);\n        // update dataRef\n        useIsomorphicLayoutEffect(()=>{\n            dataRef.current = swr.data;\n        }, [\n            swr.data\n        ]);\n        const mutate = useCallback(// eslint-disable-next-line func-names\n        function(data, opts) {\n            // When passing as a boolean, it's explicitly used to disable/enable\n            // revalidation.\n            const options = typeof opts === 'boolean' ? {\n                revalidate: opts\n            } : opts || {};\n            // Default to true.\n            const shouldRevalidate = options.revalidate !== false;\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            if (shouldRevalidate) {\n                if (!isUndefined(data)) {\n                    // We only revalidate the pages that are changed\n                    const originalData = dataRef.current;\n                    set({\n                        _i: [\n                            false,\n                            originalData\n                        ]\n                    });\n                } else {\n                    // Calling `mutate()`, we revalidate all pages\n                    set({\n                        _i: [\n                            true\n                        ]\n                    });\n                }\n            }\n            return arguments.length ? swr.mutate(data, shouldRevalidate) : swr.mutate();\n        }, // swr.mutate is always the same reference\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            cache\n        ]);\n        // Function to load pages data from the cache based on the page size.\n        const resolvePagesFromCache = (pageSize)=>{\n            // return an array of page data\n            const data = [];\n            let previousPageData = null;\n            for(let i = 0; i < pageSize; ++i){\n                var ref;\n                const [pageKey] = serialize(getKey(i, previousPageData));\n                // Get the cached page data.\n                const pageData = pageKey ? (ref = cache.get(pageKey)) == null ? void 0 : ref.data : UNDEFINED;\n                // Return the current data if we can't get it from the cache.\n                if (isUndefined(pageData)) return dataRef.current;\n                data.push(pageData);\n                previousPageData = pageData;\n            }\n            // Return the data\n            return data;\n        };\n        // Extend the SWR API\n        const setSize = useCallback((arg)=>{\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            let size;\n            if (isFunction(arg)) {\n                size = arg(resolvePageSize());\n            } else if (typeof arg == 'number') {\n                size = arg;\n            }\n            if (typeof size != 'number') return EMPTY_PROMISE;\n            set({\n                _l: size\n            });\n            lastPageSizeRef.current = size;\n            return mutate(resolvePagesFromCache(size));\n        }, // `cache` and `rerender` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            resolvePageSize,\n            mutate,\n            cache\n        ]);\n        // Use getter functions to avoid unnecessary re-renders caused by triggering\n        // all the getters of the returned swr object.\n        return {\n            size: resolvePageSize(),\n            setSize,\n            mutate,\n            get data () {\n                return swr.data;\n            },\n            get error () {\n                return swr.error;\n            },\n            get isValidating () {\n                return swr.isValidating;\n            },\n            get isLoading () {\n                return swr.isLoading;\n            }\n        };\n    };\n};\nvar index = withMiddleware(useSWR, infinite);\n\nexport { index as default, infinite, unstable_serialize };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}